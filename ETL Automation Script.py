# -*- coding: utf-8 -*-
"""Mansfield_updated.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nfBXx-6CTd6T2HTSEa2_-CdJbu8y-28s
"""



#pip install selenium
#pip install --user webdriver-manager
#pip install openpyxl

# In[2]:

import time
import shutil
import os
import pandas as pd
import calendar
from datetime import datetime, timedelta
from datetime import datetime, timedelta
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import NoSuchElementException, StaleElementReferenceException

# In[3]: Data Extraction


path = "C:\\Users\\preeti.agrawal\\Downloads"
chromeOptions = webdriver.ChromeOptions() #set options for folder creation
prefs = {"download.default_directory" : path} #setting preference for folder creation
chromeOptions.add_experimental_option("prefs",prefs)
chromeOptions.ignore_local_proxy_environment_variables()
chromeOptions.add_argument('ignore-certificate-errors')
driver = webdriver.Chrome(options=chromeOptions)
start_date = '01/01/2023'  # Replace with your actual start date
end_date = '08/13/2024'    # Replace with your actual end date

# Open the vendor site
driver.get('xyz')
# Wait for the login page to load
time.sleep(5)

# Login
username_field = driver.find_element(By.ID, 'email')
username_field.send_keys('xyz')
password_field = driver.find_element(By.ID, 'password')
password_field.send_keys('xyz')
password_field.send_keys(Keys.RETURN)
time.sleep(5)

# Navigate to the invoice tab
invoices_tab = WebDriverWait(driver, 20).until(
    EC.element_to_be_clickable((By.XPATH, "//a[contains(@href, 'invoices')]"))) #this was timing out so updated to match syntax for other elements
invoices_tab.click()
driver.implicitly_wait(15)

# Click on the "All Invoices" tab
all_invoices_button = WebDriverWait(driver, 20).until(
    EC.element_to_be_clickable((By.ID, ''))
)
all_invoices_button.click()
WebDriverWait(driver, 20).until(
    EC.presence_of_element_located((By.ID, ''))
)
all_invoices_button = driver.find_element(By.ID, '')
all_invoices_button.click()
driver.implicitly_wait(10)

# Enter Start and End Date
start_date_input = driver.find_element(By.ID, '')
start_date_input.clear()
start_date_input.send_keys(start_date)
start_date_input.send_keys(Keys.TAB)
end_date_input = WebDriverWait(driver, 20).until(
    EC.presence_of_element_located((By.ID, ''))
)
end_date_input.clear()
end_date_input.send_keys(end_date)
end_date_input.send_keys(Keys.TAB)
search_button = WebDriverWait(driver, 20).until(
    EC.element_to_be_clickable((By.ID, ''))
)
search_button.click()

# Locate the input field by ID and send keys "Dyed ULS2"
product_filter_input = driver.find_element(By.ID, "")
product_filter_input.clear()  # Clear any existing value
product_filter_input.send_keys("Dyed ULS2")
filter_button = driver.find_element(By.ID, "")
filter_button.click()
contains_option_xpath = ''
contains_option = WebDriverWait(driver, 10).until(
    EC.element_to_be_clickable((By.XPATH, contains_option_xpath))
)
contains_option.click()

WebDriverWait(driver, 10)

#export to Excel
checkbox = None

while checkbox is None:
    try:
        checkbox = driver.find_element(By.ID, "")
    except NoSuchElementException:
        time.sleep(1)  # Wait for 1 second before trying again

# Attempt to click the checkbox, with retry logic for stale elements
while True:
    try:
        checkbox.click()
        break  # Break out of the loop if successful
    except StaleElementReferenceException:
        # Re-fetch the element if it went stale
        checkbox = driver.find_element(By.ID, "")
        time.sleep(1)  # Optionally, wait a moment before retrying

# Now proceed with the rest of your code
export_link = driver.find_element(By.ID, "")
export_link.click()

# Wait for the file to download
time.sleep(10)  # Adjust the sleep time as needed

# Close the browser session
driver.quit()
#Rename the downloaded file

files = os.listdir(path)
files = [f for f in files if os.path.isfile(os.path.join(path, f))]
files.sort(key=lambda x: os.path.getmtime(os.path.join(path, x)), reverse=True)
latest_file = files[0]  # The most recently downloaded file

# Convert the string to a datetime object
end_date_obj = datetime.strptime(end_date, "%m/%d/%Y")

new_file_name = f"{end_date_obj.strftime('%Y%m%d')} -oil2.xlsx"# Define the new file name


# Full path for the current and new file
current_file_path = os.path.join(path, latest_file)
new_file_path = os.path.join(path, new_file_name)

# Rename the file
os.rename(current_file_path, new_file_path)

print(f"File renamed to: {new_file_path}")

# Define the path to the Downloads directory and the file name
file_dir = path
file_name = new_file_name
file_path = os.path.join(file_dir, file_name)

# Check if the file exists
if os.path.exists(file_path):
    # Read the Excel file into a DataFrame
    invoices_df = pd.read_excel(file_path)
    # Print the first few rows of the DataFrame to verify the content
    print(invoices_df.head())

    # Perform further actions on the DataFrame
    # Example: Print summary statistics
    print(invoices_df.head())
else:
    print(f"File {file_name} not found in directory {download_dir}")




# In[5]: Excel Workbook functions

# formatting Address column of Invoice to remove trailing space
invoices_df['ADDRESS1'] = invoices_df['ADDRESS1'].str.rstrip()

# Remove dollar signs and commas, then convert to numeric type
invoices_df['QUANTITY'] = invoices_df['QUANTITY'].str.replace(',', '', regex=False).astype(float)
invoices_df['INVOICE AMOUNT'] = invoices_df['INVOICE AMOUNT'].str.replace('$', '', regex=False).str.replace(',', '', regex=False).astype(float)

# Define file names
new_file_name = "MansfieldOil#2_billimport.csv"
exception_file_name = "Exception_Report.csv"
downloads_folder = os.path.join(os.path.expanduser("~"), "Downloads")

new_file_path = os.path.join(downloads_folder, new_file_name)
exception_file_path = os.path.join(downloads_folder, exception_file_name)

# Initialize lists to store new file data and exception rows
new_data = []
exception_data = []

# Define date format
date_format_input = "%m/%d/%Y"
date_format_output = "%Y%m%d"

# Define account reference dictionary
account_reference = {
    },

}

# Iterate over invoices DataFrame
for index, invoice_row in invoices_df.iterrows():
    # Find matching address in the reference dictionary
    account_address = invoice_row['ADDRESS1']

    if account_address in account_reference:
        # Use the matching dictionary entry
        ref_data = account_reference[account_address]

        # Prepare new row data
        invoice_date = datetime.strptime(invoice_row['INVOICE DATE'], date_format_input)
        # Start date: 1st day of the delivery month
        start_date = invoice_date.replace(day=1).strftime(date_format_output)

        # End date: last day of the delivery month
        last_day_of_month = calendar.monthrange(invoice_date.year, invoice_date.month)[1]
        end_date = invoice_date.replace(day=last_day_of_month).strftime(date_format_output)

        new_row = {
            'ACCOUNTCODE': ref_data['Account Number'],
            'STARTDATE(YYYYMMDD)': start_date,
            'ENDDATE(YYYYMMDD)': end_date,
            'ACE': "A",
            'METERCODE': ref_data['Meter Code'],
            'VENDORCODE': "Mans_",
            'USE:GAL:Usage': invoice_row['QUANTITY'],
            'TOTALCOST:USDOLLARS:Total Amount': invoice_row['INVOICE AMOUNT']
        }

        new_data.append(new_row)
    else:
        # If no match, add to exception data
        exception_data.append(invoice_row)

# Create DataFrames for new data and exceptions
new_df = pd.DataFrame(new_data)
exception_df = pd.DataFrame(exception_data, columns=invoices_df.columns)

# Save to Excel files
new_df.to_csv(new_file_path, index=False)
exception_df.to_csv(exception_file_path, index=False)

print("Processing complete. Files have been saved.")

#Rename the downloaded file

files = os.listdir(path)
files = [f for f in files if os.path.isfile(os.path.join(path, f))]
files.sort(key=lambda x: os.path.getmtime(os.path.join(path, x)), reverse=True)
latest_file = files[0]  # The most recently downloaded file

# Convert the string to a datetime object
end_date_obj = datetime.strptime(end_date, "%m/%d/%Y")

new_file_name = f"{end_date_obj.strftime('%Y%m%d')} Mansfield-oil2.xlsx"# Define the new file name


# Full path for the current and new file
current_file_path = os.path.join(path, latest_file)
new_file_path = os.path.join(path, new_file_name)

# Rename the file
os.rename(current_file_path, new_file_path)

print(f"File renamed to: {new_file_path}")

